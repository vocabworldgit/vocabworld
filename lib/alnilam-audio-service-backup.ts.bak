// Alnilam Audio Service - Beautiful multilingual TTS with perfect voice quality
// Connects to the comprehensive audio library generated with Alnilam voice personality

export interface AlnilamAudioSettings {
  autoPlay: boolean;
  trainingVoice: 'Female' | 'Male';  // Future implementation
  mainVoice: 'Female' | 'Male';      // Future implementation
  speed: 'Slow' | 'Normal' | 'Fast';
  pauseBetweenTranslations: number;   // 0.2s to 10s
  pauseForNextWord: number;           // 0.2s to 10s
  repeatTargetWord: number;           // 1x to 5x
  repeatMainWord: number;             // 1x to 5x
}

export interface AlnilamWord {
  id: number;
  word_en: string;
  translated_word: string;
  source_language: string;
  target_language: string;
  topic_name?: string;
}

export class AlnilamAudioService {
  private currentAudio: HTMLAudioElement | null = null;
  private isPlaying: boolean = false;
  private audioCache: Map<string, HTMLAudioElement> = new Map();
  private currentSequence: AbortController | null = null;

  constructor() {
    console.log('üåä Alnilam Audio Service initialized - Beautiful multilingual TTS');
  }

  /**
   * Get audio URL for a specific word and language
   */
  private getAudioUrl(wordId: number, languageCode: string, topicName?: string): string {
    const params = new URLSearchParams({
      wordId: wordId.toString(),
      languageCode: languageCode
    });
    
    if (topicName) {
      params.append('topic', topicName);
    }
    
    return `/api/alnilam-audio?${params.toString()}`;
  }

  /**
   * Preload audio for better performance
   */
  private async preloadAudio(url: string): Promise<HTMLAudioElement> {
    if (this.audioCache.has(url)) {
      return this.audioCache.get(url)!;
    }

    return new Promise((resolve, reject) => {
      const audio = new Audio(url);
      audio.preload = 'auto';
      
      audio.addEventListener('canplaythrough', () => {
        this.audioCache.set(url, audio);
        console.log(`‚úÖ Alnilam audio preloaded: ${url}`);
        resolve(audio);
      });
      
      audio.addEventListener('error', (e) => {
        console.error('‚ùå Alnilam audio preload failed:', url, e);
        reject(e);
      });
      
      // Start loading
      audio.load();
    });
  }

  /**
   * Play audio for a specific word with Alnilam's beautiful voice
   */
  async playWordAudio(
    wordId: number, 
    languageCode: string, 
    topicName?: string
  ): Promise<boolean> {
    try {
      console.log(`üåä Alnilam playing: word ${wordId} in ${languageCode}`);
      
      // Stop any currently playing audio
      this.stopAudio();
      
      const audioUrl = this.getAudioUrl(wordId, languageCode, topicName);
      console.log(`üéØ Constructed audio URL: ${audioUrl}`);
      
      // Check if file exists by trying to load it
      let audio: HTMLAudioElement;
      try {
        console.log(`üîÑ Attempting to preload audio from: ${audioUrl}`);
        audio = await this.preloadAudio(audioUrl);
        console.log(`‚úÖ Audio preloaded successfully`);
      } catch (error) {
        console.warn(`‚ùå Alnilam audio not found: ${audioUrl}`, error);
        return false;
      }

      // Play the audio
      this.currentAudio = audio;
      this.isPlaying = true;
      
      console.log(`‚ñ∂Ô∏è Starting audio playback for word ${wordId}`);
      return new Promise((resolve) => {
        const onEnded = () => {
          console.log(`‚úÖ Alnilam audio completed: word ${wordId}`);
          this.isPlaying = false;
          audio.removeEventListener('ended', onEnded);
          audio.removeEventListener('error', onError);
          resolve(true);
        };

        const onError = (error: any) => {
          console.error(`‚ùå Alnilam audio playback error:`, error);
          this.isPlaying = false;
          audio.removeEventListener('ended', onEnded);
          audio.removeEventListener('error', onError);
          resolve(false);
        };

        audio.addEventListener('ended', onEnded);
        audio.addEventListener('error', onError);
        
        audio.play().catch(onError);
      });

    } catch (error) {
      console.error(`‚ùå Alnilam playWordAudio error:`, error);
      return false;
    }
  }

  /**
   * Stop currently playing audio
   */
  stopAudio(): void {
    if (this.currentAudio && this.isPlaying) {
      this.currentAudio.pause();
      this.currentAudio.currentTime = 0;
      this.currentAudio = null;
      this.isPlaying = false;
      console.log('üõë Alnilam audio stopped');
    }

    // Stop any running sequence
    if (this.currentSequence) {
      this.currentSequence.abort();
      this.currentSequence = null;
    }
  }

  /**
   * Play complete word sequence according to user settings
   * This includes: Training language ‚Üí Target language ‚Üí Pauses ‚Üí Repeats
   */
  async playWordSequence(
    word: AlnilamWord, 
    settings: AlnilamAudioSettings
  ): Promise<void> {
    console.log(`üåä Alnilam sequence: "${word.word_en}" ‚Üí "${word.translated_word}"`);
    
    // Stop any existing sequence
    this.stopAudio();
    
    // Create abort controller for this sequence
    this.currentSequence = new AbortController();
    const signal = this.currentSequence.signal;

    try {
      // Step 1: Play training language word (repeat based on settings)
      for (let i = 0; i < settings.repeatTargetWord; i++) {
        if (signal.aborted) return;
        
        const success = await this.playWordAudio(
          word.id, 
          word.source_language, 
          word.topic_name
        );
        
        if (!success) {
          console.warn(`‚ö†Ô∏è Training audio not available for word ${word.id} in ${word.source_language}`);
        }
        
        // Pause between repeats (except last one)
        if (i < settings.repeatTargetWord - 1) {
          await this.sleep(settings.pauseBetweenTranslations * 1000);
        }
      }

      // Step 2: Pause between languages
      if (signal.aborted) return;
      await this.sleep(settings.pauseBetweenTranslations * 1000);

      // Step 3: Play main language word (repeat based on settings)
      for (let i = 0; i < settings.repeatMainWord; i++) {
        if (signal.aborted) return;
        
        const success = await this.playWordAudio(
          word.id, 
          word.target_language, 
          word.topic_name
        );
        
        if (!success) {
          console.warn(`‚ö†Ô∏è Main audio not available for word ${word.id} in ${word.target_language}`);
        }
        
        // Pause between repeats (except last one)
        if (i < settings.repeatMainWord - 1) {
          await this.sleep(settings.pauseBetweenTranslations * 1000);
        }
      }

      // Step 4: Final pause before next word
      if (signal.aborted) return;
      await this.sleep(settings.pauseForNextWord * 1000);

      console.log(`‚úÖ Alnilam sequence completed: "${word.word_en}" ‚Üí "${word.translated_word}"`);

    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error(`‚ùå Alnilam sequence error:`, error);
      }
    } finally {
      this.currentSequence = null;
    }
  }

  /**
   * Auto-play through all words with Alnilam's beautiful voice
   */
  async playAllWords(
    words: AlnilamWord[], 
    settings: AlnilamAudioSettings,
    onWordChange?: (index: number, word: AlnilamWord) => void,
    onComplete?: () => void
  ): Promise<void> {
    console.log(`üåä Alnilam auto-play: ${words.length} words`);

    this.stopAudio();

    try {
      for (let i = 0; i < words.length; i++) {
        // Notify about word change
        onWordChange?.(i, words[i]);

        // Play word sequence
        await this.playWordSequence(words[i], settings);

        // Check if we should continue (auto-play might be stopped)
        if (!settings.autoPlay) {
          break;
        }
      }

      console.log(`‚úÖ Alnilam auto-play completed`);
      onComplete?.();

    } catch (error) {
      console.error(`‚ùå Alnilam auto-play error:`, error);
    }
  }

  /**
   * Check if audio is available for a word in a language
   */
  async checkAudioAvailability(
    wordId: number, 
    languageCode: string, 
    topicName?: string
  ): Promise<boolean> {
    try {
      const audioUrl = this.getAudioUrl(wordId, languageCode, topicName);
      const response = await fetch(audioUrl, { method: 'HEAD' });
      return response.ok;
    } catch {
      return false;
    }
  }

  /**
   * Get current playback status
   */
  getPlaybackStatus(): { isPlaying: boolean; hasSequence: boolean } {
    return {
      isPlaying: this.isPlaying,
      hasSequence: this.currentSequence !== null
    };
  }

  /**
   * Apply speed settings to audio
   */
  private applySpeedSettings(audio: HTMLAudioElement, speed: 'Slow' | 'Normal' | 'Fast'): void {
    switch (speed) {
      case 'Slow':
        audio.playbackRate = 0.7;
        break;
      case 'Fast':
        audio.playbackRate = 1.3;
        break;
      default:
        audio.playbackRate = 1.0;
        break;
    }
  }

  /**
   * Sleep utility for controlled timing
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Clear audio cache (useful for memory management)
   */
  clearCache(): void {
    this.audioCache.clear();
    console.log('üßπ Alnilam audio cache cleared');
  }

  /**
   * Compatibility method for existing component interface
   * Adapts the component's call to our internal interface
   */
  async playWordSequence(
    word: { id: number; sourceWord: string; targetWord: string },
    targetLanguage: string,
    nativeLanguage: string,
    componentSettings: {
      speed: 'Slow' | 'Normal' | 'Fast';
      pauseBetweenTranslations: number;
      pauseForNextWord: number;
      repeatTargetLanguage: number;
      repeatMainLanguage: number;
      setCurrentAudioStep?: (step: string) => void;
    }
  ): Promise<boolean> {
    try {
      console.log(`üåü Alnilam adapter: "${word.sourceWord}" ‚Üí "${word.targetWord}"`);
      
      // Map to internal settings format
      const internalSettings: AlnilamAudioSettings = {
        autoPlay: false,
        trainingVoice: 'Male',
        mainVoice: 'Male', 
        speed: componentSettings.speed,
        pauseBetweenTranslations: componentSettings.pauseBetweenTranslations,
        pauseForNextWord: componentSettings.pauseForNextWord,
        repeatTargetWord: componentSettings.repeatTargetLanguage,
        repeatMainWord: componentSettings.repeatMainLanguage
      };

      // Convert language names to codes
      const sourceLanguageCode = this.getLanguageCode(targetLanguage);
      const targetLanguageCode = this.getLanguageCode(nativeLanguage);

      if (!sourceLanguageCode) {
        console.warn(`‚ùå Unknown source language: ${targetLanguage}`);
        return false;
      }

      console.log(`üåä Playing word ${word.id}: ${word.sourceWord} (${targetLanguage}) ‚Üí ${word.targetWord} (${nativeLanguage})`);

      // Step 1: Play training language (what user is learning)
      if (componentSettings.setCurrentAudioStep) {
        componentSettings.setCurrentAudioStep('training');
      }
      
      console.log(`üéØ Step 1: Playing training language - wordId: ${word.id}, language: ${sourceLanguageCode}`);
      for (let i = 0; i < componentSettings.repeatTargetLanguage; i++) {
        const success = await this.playWordAudio(word.id, sourceLanguageCode);
        console.log(`üéØ Training language attempt ${i + 1}: ${success ? 'SUCCESS' : 'FAILED'}`);
        if (!success) {
          console.warn(`‚ùå Failed to play training language for word ${word.id}`);
          return false;
        }
        if (i < componentSettings.repeatTargetLanguage - 1) {
          await this.sleep(300); // Brief pause between repeats
        }
      }

      // Pause between languages
      if (componentSettings.setCurrentAudioStep) {
        componentSettings.setCurrentAudioStep('pause');
      }
      await this.sleep(componentSettings.pauseBetweenTranslations * 1000);

      // Step 2: Play native language (user's target language) 
      if (componentSettings.setCurrentAudioStep) {
        componentSettings.setCurrentAudioStep('main');
      }
      
      for (let i = 0; i < componentSettings.repeatMainLanguage; i++) {
        // For native language, try to find English audio first, then fall back to target language audio
        let success = false;
        if (targetLanguageCode && targetLanguageCode !== 'en') {
          success = await this.playWordAudio(word.id, 'en'); // Try English first
        }
        if (!success && targetLanguageCode) {
          success = await this.playWordAudio(word.id, targetLanguageCode);
        }
        
        if (!success) {
          console.warn(`‚ùå Failed to play native language for word ${word.id}`);
          return false;
        }
        if (i < componentSettings.repeatMainLanguage - 1) {
          await this.sleep(300); // Brief pause between repeats
        }
      }

      if (componentSettings.setCurrentAudioStep) {
        componentSettings.setCurrentAudioStep('idle');
      }

      console.log('‚úÖ Alnilam word sequence completed successfully');
      return true;

    } catch (error) {
      console.error('‚ùå Alnilam sequence error:', error);
      if (componentSettings.setCurrentAudioStep) {
        componentSettings.setCurrentAudioStep('idle');
      }
      return false;
    }
  }

  /**
   * Convert language name to language code for file lookup
   */
  private getLanguageCode(languageName: string): string | null {
    const languageMap: { [key: string]: string } = {
      'Arabic': 'ar',
      'German': 'de', 
      'Spanish': 'es',
      'French': 'fr',
      'Hindi': 'hi',
      'Indonesian': 'id',
      'Italian': 'it',
      'Japanese': 'ja',
      'Korean': 'ko',
      'Portuguese': 'pt',
      'Russian': 'ru',
      'Dutch': 'nl',
      'Polish': 'pl', 
      'Thai': 'th',
      'Turkish': 'tr',
      'Vietnamese': 'vi',
      'Romanian': 'ro',
      'Ukrainian': 'uk',
      'Bengali': 'bn',
      'Marathi': 'mr',
      'Tamil': 'ta',
      'Telugu': 'te',
      'English': 'en'
    };
    
    return languageMap[languageName] || null;
  }
}

// Export singleton instance
export const alnilamAudioService = new AlnilamAudioService();
